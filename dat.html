<html>
<head>
<!-- import some shit -->
</head>
<body>

<div>

<canvas id="mrcanvas">

</canvas>

</div>

<div>
<h4>
Intructerinos
</h4>
<p>
	Left click select a triangle, middle click toggles pathability, right click adds a vertex to the graph 
<p>
</div>

<script type="text/javascript">

//magic javascript conventions
//CapCase is global
//camelCase is local
//no actual scoping because yolo

Array.prototype.remove = function(val) {
    for (var i = 0; i < this.length; i++) {
        if (this[i] === val) {
            this.splice(i, 1);
            i--;
        }
    }
    return this;
}

//rendering and event handling be here

//some magic numbers, "immutable" rofl
var TOPLEFT = { x: 0, y: 0 };
var TOPRIGHT = { x: 690, y: 0 };
var BOTTOMLEFT = { x: 0, y: 420 };
var BOTTOMRIGHT = { x: 690, y: 420 };

var c=document.getElementById("mrcanvas");
c.width = 690;
c.height = 420;
c.oncontextmenu = function (e) {
    e.preventDefault();
};

var MouseDown = function(e) {
	var x = e.pageX;
	var y = e.pageY;

	//left click
	if(e.button === 0) {
		console.log(x - c.offsetLeft, y - c.offsetTop);
		SelectTriangle(x - c.offsetLeft, y - c.offsetTop);
	}
	//middle click
	if(e.button === 1) {
		TogglePathability(x - c.offsetLeft, y - c.offsetTop);
	}
	//right click
	if(e.button === 2) {
		var vertex = { x: x - c.offsetLeft, y: y - c.offsetTop};
		AddVertex(vertex);
		DrawTriangles();
	}
}

c.addEventListener("mousedown", MouseDown, false);
var Ctx=c.getContext("2d");
//ctx.strokeStyle="#FF0000";
//ctx.strokeStyle(xpos,ypos,width,height);
//ctx.drawLine(x1, y1, x2, y2);
Ctx.lineWidth = 2;

var DrawTriangle = function(triangle, highlight) {
	if(highlight) {
		Ctx.strokeStyle="#FF0000";
	} else {
		Ctx.strokeStyle="#0000FF";
	}
	Ctx.beginPath();
	for (var i = 0; i < 3; i++) {
		var j = (i + 1) % 3;
		var x1 = triangle.vertices[i].x;
		var y1 = triangle.vertices[i].y;
		var x2 = triangle.vertices[j].x;
		var y2 = triangle.vertices[j].y;
		if(i === 0) {
			Ctx.moveTo(x1, y1);
		}
		Ctx.lineTo(x2, y2);
	}
	Ctx.closePath();
	if(!triangle.pathable) {
		Ctx.fillStyle = "#0000FF";
		Ctx.fill();
	}
	Ctx.stroke();
}

var DrawTriangles = function() { 
		Ctx.clearRect(0, 0, c.width, c.height);
	for(var i = 0; i < Triangles.length; i++) {
		DrawTriangle(Triangles[i]);
	}
}

</script>

<script type="text/javascript">

//triangle array
var Triangles = [];

//triangle object 
var Triangle = function(v1, v2, v3) {
	this.vertices = [ v1, v2, v3 ];
	this.adjacent = [];
	this.dead = false;
	this.pathable = true;
}
//v for vertexxa
Triangle.prototype.IsVertexInside = function(v) {
	var a = this.vertices[0];
	var b = this.vertices[1];
	var c = this.vertices[2];
	
	var av_x = v.x - a.x;
	var av_y = v.y - a.y;

	var v_ab = (b.x - a.x) * av_y - (b.y - a.y) * av_x > 0;

	if((c.x - a.x) * av_y - (c.y - a.y) * av_x > 0 == v_ab) return false;

	if((c.x - b.x) * (v.y - b.y) - (c.y - b.y) * (v.x - b.x) > 0 != v_ab) return false;

	return true;
}
//v for vertex, r for radius
Triangle.prototype.HasPointInCircle = function(triangle) {
	var p = triangle.UniqueVertex(this);

	var one = this.vertices[0];
	var two = this.vertices[1];
	var three = this.vertices[2];
	
	//arange points counter clockwise because reasons
	if(!IsLeft([ three, one ], two)) {
		var temp = one;
		one = two;
		two = temp;
	}
	
	var a = one.x - p.x;
	var b = one.y - p.y;
	var c = (one.x * one.x - p.x * p.x) + (one.y * one.y - p.y * p.y);
	var d = two.x - p.x;
	var e = two.y - p.y;
	var f = (two.x * two.x - p.x * p.x) + (two.y * two.y - p.y * p.y);
	var g = three.x - p.x;
	var h = three.y - p.y;
	var i = (three.x * three.x - p.x * p.x) + (three.y * three.y - p.y * p.y);
	
	var det = (a * (e * i - f * h)) - (b * (d * i - f * g)) + (c * (d * h - e * g));
	
	return det > 0;
}
//returns the unique vertex of the current triangle given the passed triangle
Triangle.prototype.UniqueVertex = function(triangle) {
	for(var i = 0; i < 3; i++) {
		var equal = false;
		for(var j = 0; j < 3; j++) {
			if(this.vertices[i].x == triangle.vertices[j].x && this.vertices[i].y == triangle.vertices[j].y) {
				equal = true;
			}
		}
		if(!equal) {
			return this.vertices[i];
		}
	}
	return null;
}
//returns if the triangles share two vertices
Triangle.prototype.ShareTwoPoints = function(other) {
	var count = 0;
	for(var i = 0; i < 3; i++) {
		for(var j = 0; j < 3; j++) {
			if(this.vertices[i].x == other.vertices[j].x && this.vertices[i].y == other.vertices[j].y) {
				count++;
			}
		}
	}
	return 2 == count;
}
//Adds a vertex to the current triangle. this kills the current triangle
Triangle.prototype.AddVertex = function(vertex) {
	var triangle = GetTriangle(vertex);

	var t1 = new Triangle(this.vertices[0], this.vertices[1], vertex);
	var t2 = new Triangle(this.vertices[1], this.vertices[2], vertex);
	var t3 = new Triangle(this.vertices[0], this.vertices[2], vertex);

	for(var i = 0; i < this.adjacent.length; i++) {
		var t = this.adjacent[i];
		t.adjacent.remove(this);
		if(t1.ShareTwoPoints(t)) {
			t.adjacent.push(t1);
			t1.adjacent.push(t);
		}
		if(t2.ShareTwoPoints(t)) {
			t.adjacent.push(t2);
			t2.adjacent.push(t);
		}
		if(t3.ShareTwoPoints(t)) {
			t.adjacent.push(t3);
			t3.adjacent.push(t);
		}
	}
	
	t1.adjacent.push(t2);
	t1.adjacent.push(t3);
	
	t2.adjacent.push(t1);
	t2.adjacent.push(t3);
	
	t3.adjacent.push(t1);
	t3.adjacent.push(t2);
	
	Triangles.push(t1);
	Triangles.push(t2);
	Triangles.push(t3);
	
	Triangles.remove(this);
	
	return [ t1, t2, t3 ];
}
//Gets the vertices shared between the two triangles
Triangle.prototype.SharedVertices = function(other) {
	var shared = [];
	var numfound = 0;
	for(var i = 0; i < 3; i++) {
		for(var j = 0; j < 3; j++) {
			if(this.vertices[i].x == other.vertices[j].x && this.vertices[i].y == other.vertices[j].y) {
				shared[numfound++] = this.vertices[i];
			}
		}
	}
	return shared;
}


//fun static methods because organisation is for scrubs

//determines if candidate is to the left of line where line is vertex a -> b
var IsLeft = function(line, candidate) {
	return ((line[1].x - line[0].x)*(candidate.y - line[0].y) - (line[1].y - line[0].y)*(candidate.x - line[0].x)) >= 0;
}

var GetTriangle = function(vertex) {
	for(var i = 0; i < Triangles.length; i++) {
		if(Triangles[i].IsVertexInside(vertex)) {
			return Triangles[i];
		}
	}
	return null;
}

var Flip = function(t1, t2) {
	var common = t1.SharedVertices(t2);
	
	var uncommon = [];
	uncommon[0] = t1.UniqueVertex(t2);
	uncommon[1] = t2.UniqueVertex(t1);
	
	//make new triangles
	var t1n = new Triangle(uncommon[0], uncommon[1], common[0]);
	var t2n = new Triangle(uncommon[0], uncommon[1], common[1]);
	
	var adjacents = [];
	
	for(var i = 0; i < t1.adjacent.length; i++) {
		adjacents.push(t1.adjacent[i]);
	}
	for(var i = 0; i < t2.adjacent.length; i++) {
		adjacents.push(t2.adjacent[i]);
	}
	adjacents.remove(t1);
	adjacents.remove(t2);
	
	//remove old triangles from their neighbours adjacent lists
	for(var i = 0; i < t1.adjacent.length; i++) {
		var t = t1.adjacent[i];
		t.adjacent.remove(t1);
	}
	
	for(var i = 0; i < t2.adjacent.length; i++) {
		var t = t2.adjacent[i];
		t.adjacent.remove(t2);
	}
	
	for(var i = 0; i < adjacents.length; i++) {
		var t = adjacents[i];
		if(t1n.ShareTwoPoints(t)) {
			t.adjacent.push(t1n);
			t1n.adjacent.push(t);
		}
		
		if(t2n.ShareTwoPoints(t)) {
			t.adjacent.push(t2n);
			t2n.adjacent.push(t);
		}	
	}
	
	t1n.adjacent.push(t2n);
	t2n.adjacent.push(t1n);
		
	Triangles.remove(t1);
	t1.dead = true;
	Triangles.remove(t2);
	t2.dead = true;
	Triangles.push(t1n);
	Triangles.push(t2n);
			
	return [ t1n, t2n ];
}

var AddVertex = function(vertex) {
	var inside = null;
	var edge = null;

	for(var i = 0; i < Triangles.length; i++) {
		var t = Triangles[i];
		if(t.IsVertexInside(vertex)) {
			inside = t;
		}
		/*
		if(t.IsVertexOnEdge(vertex)) {
			edge = t;
		}
		*/
		if(edge != null || inside != null) {
			break;
		}
	}
	/*
	if(edge != null) {
		var newTriangles = edge.addVertexToEdge(v);
		for(var i = 0; i < newTriangles.length; i++) {
			if(!newTriangles[i].dead) {
				CheckAndFlip(newTriangles[i]);
			}
		}
		return;
	}
	*/
	if(inside != null) {
		var newTriangles = inside.AddVertex(vertex);
		for(var i = 0; i < newTriangles.length; i++) {
			if(!newTriangles[i].dead) {
				CheckAndFlip(newTriangles[i]);
			}
		}
	}
}

var CheckAndFlip = function(t) {
			
	for(var i = 0; i < t.adjacent.length; i++) {
		var tt = t.adjacent[i];
					
		if(t.HasPointInCircle(tt)) {
			var newTriangles = Flip(t, tt);
			CheckAndFlip(newTriangles[0]);
			if(!newTriangles[1].dead) {
				CheckAndFlip(newTriangles[1]);
			}
			return;
		}
	}
}

//interactive bs

var SelectTriangle = function(x, y) {
	DrawTriangles();
	var vertex = {
		x: x,
		y: y
	}
	var triangle = GetTriangle(vertex);
	DrawTriangle(triangle, true);
}

var TogglePathability = function(x, y) {
	var vertex = {
		x: x,
		y: y
	}
	var triangle = GetTriangle(vertex);
	if(triangle !== null) {		
		triangle.pathable = !triangle.pathable;
		DrawTriangles();
	}
}

var Prepared = function() {
	Initialize();
	
	var data = [
		{ x: 87, y: 147 },
		{ x: 104, y: 203 },
		{ x: 137, y: 220 },
		{ x: 98, y: 271 },
		{ x: 166, y: 380 },
		{ x: 182, y: 330 },
		{ x: 186, y: 349 },
		{ x: 304, y: 375 },
		{ x: 265, y: 305 },
		{ x: 320, y: 336 },
		{ x: 206, y: 290 },
		{ x: 203, y: 245 },
		{ x: 262, y: 213 },
		{ x: 157, y: 191 },
		{ x: 173, y: 172 },
		{ x: 172, y: 130 },
		{ x: 101, y: 108 },
		{ x: 210, y: 54 },
		{ x: 275, y: 36 },
		{ x: 260, y: 99 },
		{ x: 311, y: 124 },
		{ x: 369, y: 107 },
		{ x: 388, y: 42 },
		{ x: 419, y: 84 },
		{ x: 477, y: 41 },
		{ x: 518, y: 65 },
		{ x: 519, y: 266 },
		{ x: 541, y: 200 },
		{ x: 546, y: 238 },
		{ x: 575, y: 282 },
		{ x: 609, y: 246 },
		{ x: 629, y: 189 },
		{ x: 548, y: 157 },
		{ x: 620, y: 125 },
		{ x: 533, y: 110 },
		{ x: 616, y: 54 },
		{ x: 655, y: 255 },
		{ x: 619, y: 328 },
		{ x: 547, y: 349 },
		{ x: 449, y: 306 },
		{ x: 447, y: 255 },
		{ x: 457, y: 191 },
		{ x: 444, y: 151 },
		{ x: 409, y: 292 },
		{ x: 369, y: 187 }
	];
	
	for(var i = 0; i < data.length; i++) {
		AddVertex(data[i]);
	}
	
	var pathability = [
		{ x: 128, y: 126 },
		{ x: 101, y: 155 },
		{ x: 143, y: 150 },
		{ x: 117, y: 185 },
		{ x: 130, y: 206 },
		{ x: 112, y: 224 },
		{ x: 145, y: 241 },
		{ x: 189, y: 247 },
		{ x: 158, y: 305 },
		{ x: 166, y: 337 },
		{ x: 199, y: 361 },
		{ x: 231, y: 342 },
		{ x: 209, y: 309 },
		{ x: 296, y: 333 },
		{ x: 277, y: 157 },
		{ x: 247, y: 61 },
		{ x: 291, y: 80 },
		{ x: 323, y: 76 },
		{ x: 350, y: 61 },
		{ x: 409, y: 61 },
		{ x: 478, y: 58 },
		{ x: 493, y: 84 },
		{ x: 492, y: 119 },
		{ x: 402, y: 130 },
		{ x: 413, y: 103 },
		{ x: 436, y: 170 },
		{ x: 422, y: 201 },
		{ x: 472, y: 232 },
		{ x: 423, y: 260 },
		{ x: 456, y: 274 },
		{ x: 495, y: 300 },
		{ x: 560, y: 318 },
		{ x: 550, y: 286 },
		{ x: 549, y: 252 },
		{ x: 599, y: 280 },
		{ x: 567, y: 246 },
		{ x: 630, y: 258 },
		{ x: 573, y: 228 },
		{ x: 640, y: 232 },
		{ x: 576, y: 212 },
		{ x: 569, y: 181 },
		{ x: 645, y: 204 },
		{ x: 610, y: 164 },
		{ x: 633, y: 85 },
		{ x: 193, y: 332 },
		{ x: 182, y: 349 },
		{ x: 400, y: 78 },
		{ x: 634, y: 128 }
	];
	
	for(var i = 0; i < pathability.length; i++) {
		TogglePathability(pathability[i].x, pathability[i].y);
	}
	
	DrawTriangles();
}

</script>

<script type="text/javascript">

//init rubbish
var Initialize = function() {

Triangles = [];

var t1 = new Triangle(TOPLEFT, TOPRIGHT, BOTTOMLEFT);
var t2 = new Triangle(BOTTOMRIGHT, TOPRIGHT, BOTTOMLEFT);
t1.adjacent.push(t2);
t2.adjacent.push(t1);
Triangles.push(t1);
Triangles.push(t2);

DrawTriangles();

}

window.onload = function() {
	Initialize();
}

</script>

<style type="text/css">

#mrcanvas {
	width: 690px;;
	height: 420px;
}

</style>


</body>
</html>